// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: data.proto

package api

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for FirstName

	// no validation rules for LastName

	// no validation rules for Email

	// no validation rules for Phone

	// no validation rules for Country

	// no validation rules for Company

	// no validation rules for Position

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on Setting with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Setting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Setting with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SettingMultiError, or nil if none found.
func (m *Setting) ValidateAll() error {
	return m.validate(true)
}

func (m *Setting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NotifyCreateSource

	// no validation rules for NotifyCreateDestination

	// no validation rules for NotifyCreateMasterSegment

	// no validation rules for NotifyCreateSegment

	if len(errors) > 0 {
		return SettingMultiError(errors)
	}

	return nil
}

// SettingMultiError is an error wrapping multiple validation errors returned
// by Setting.ValidateAll() if the designated constraints aren't met.
type SettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SettingMultiError) AllErrors() []error { return m }

// SettingValidationError is the validation error returned by Setting.Validate
// if the designated constraints aren't met.
type SettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SettingValidationError) ErrorName() string { return "SettingValidationError" }

// Error satisfies the builtin error interface
func (e SettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SettingValidationError{}

// Validate checks the field values on MappingOptionItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MappingOptionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MappingOptionItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MappingOptionItemMultiError, or nil if none found.
func (m *MappingOptionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *MappingOptionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceFieldName

	// no validation rules for DestinationFieldName

	if len(errors) > 0 {
		return MappingOptionItemMultiError(errors)
	}

	return nil
}

// MappingOptionItemMultiError is an error wrapping multiple validation errors
// returned by MappingOptionItem.ValidateAll() if the designated constraints
// aren't met.
type MappingOptionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MappingOptionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MappingOptionItemMultiError) AllErrors() []error { return m }

// MappingOptionItemValidationError is the validation error returned by
// MappingOptionItem.Validate if the designated constraints aren't met.
type MappingOptionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MappingOptionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MappingOptionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MappingOptionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MappingOptionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MappingOptionItemValidationError) ErrorName() string {
	return "MappingOptionItemValidationError"
}

// Error satisfies the builtin error interface
func (e MappingOptionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMappingOptionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MappingOptionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MappingOptionItemValidationError{}

// Validate checks the field values on ImportCsvConfigurations with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportCsvConfigurations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportCsvConfigurations with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportCsvConfigurationsMultiError, or nil if none found.
func (m *ImportCsvConfigurations) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportCsvConfigurations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDelimiter()) != 1 {
		err := ImportCsvConfigurationsValidationError{
			field:  "Delimiter",
			reason: "value length must be 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if m.GetSkipRows() <= -1 {
		err := ImportCsvConfigurationsValidationError{
			field:  "SkipRows",
			reason: "value must be greater than -1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for MultiLine

	if len(errors) > 0 {
		return ImportCsvConfigurationsMultiError(errors)
	}

	return nil
}

// ImportCsvConfigurationsMultiError is an error wrapping multiple validation
// errors returned by ImportCsvConfigurations.ValidateAll() if the designated
// constraints aren't met.
type ImportCsvConfigurationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportCsvConfigurationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportCsvConfigurationsMultiError) AllErrors() []error { return m }

// ImportCsvConfigurationsValidationError is the validation error returned by
// ImportCsvConfigurations.Validate if the designated constraints aren't met.
type ImportCsvConfigurationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportCsvConfigurationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportCsvConfigurationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportCsvConfigurationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportCsvConfigurationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportCsvConfigurationsValidationError) ErrorName() string {
	return "ImportCsvConfigurationsValidationError"
}

// Error satisfies the builtin error interface
func (e ImportCsvConfigurationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportCsvConfigurations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportCsvConfigurationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportCsvConfigurationsValidationError{}

// Validate checks the field values on TransferredColumn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransferredColumn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferredColumn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferredColumnMultiError, or nil if none found.
func (m *TransferredColumn) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferredColumn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TableColumnName

	// no validation rules for NewTableColumnName

	if len(errors) > 0 {
		return TransferredColumnMultiError(errors)
	}

	return nil
}

// TransferredColumnMultiError is an error wrapping multiple validation errors
// returned by TransferredColumn.ValidateAll() if the designated constraints
// aren't met.
type TransferredColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferredColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferredColumnMultiError) AllErrors() []error { return m }

// TransferredColumnValidationError is the validation error returned by
// TransferredColumn.Validate if the designated constraints aren't met.
type TransferredColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferredColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferredColumnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferredColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferredColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferredColumnValidationError) ErrorName() string {
	return "TransferredColumnValidationError"
}

// Error satisfies the builtin error interface
func (e TransferredColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferredColumn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferredColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferredColumnValidationError{}

// Validate checks the field values on SchemaColumn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SchemaColumn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchemaColumn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SchemaColumnMultiError, or
// nil if none found.
func (m *SchemaColumn) ValidateAll() error {
	return m.validate(true)
}

func (m *SchemaColumn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ColumnName

	// no validation rules for DataType

	if len(errors) > 0 {
		return SchemaColumnMultiError(errors)
	}

	return nil
}

// SchemaColumnMultiError is an error wrapping multiple validation errors
// returned by SchemaColumn.ValidateAll() if the designated constraints aren't met.
type SchemaColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchemaColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchemaColumnMultiError) AllErrors() []error { return m }

// SchemaColumnValidationError is the validation error returned by
// SchemaColumn.Validate if the designated constraints aren't met.
type SchemaColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemaColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemaColumnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemaColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemaColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemaColumnValidationError) ErrorName() string { return "SchemaColumnValidationError" }

// Error satisfies the builtin error interface
func (e SchemaColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchemaColumn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemaColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemaColumnValidationError{}

// Validate checks the field values on MasterSegment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MasterSegment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MasterSegment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MasterSegmentMultiError, or
// nil if none found.
func (m *MasterSegment) ValidateAll() error {
	return m.validate(true)
}

func (m *MasterSegment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return MasterSegmentMultiError(errors)
	}

	return nil
}

// MasterSegmentMultiError is an error wrapping multiple validation errors
// returned by MasterSegment.ValidateAll() if the designated constraints
// aren't met.
type MasterSegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MasterSegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MasterSegmentMultiError) AllErrors() []error { return m }

// MasterSegmentValidationError is the validation error returned by
// MasterSegment.Validate if the designated constraints aren't met.
type MasterSegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MasterSegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MasterSegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MasterSegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MasterSegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MasterSegmentValidationError) ErrorName() string { return "MasterSegmentValidationError" }

// Error satisfies the builtin error interface
func (e MasterSegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMasterSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MasterSegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MasterSegmentValidationError{}

// Validate checks the field values on MasterSegmentDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MasterSegmentDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MasterSegmentDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MasterSegmentDetailMultiError, or nil if none found.
func (m *MasterSegmentDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *MasterSegmentDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Status

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for AudienceTableId

	// no validation rules for MainRawTableId

	// no validation rules for MainRawTableName

	for idx, item := range m.GetAttributeTables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MasterSegmentDetailValidationError{
						field:  fmt.Sprintf("AttributeTables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MasterSegmentDetailValidationError{
						field:  fmt.Sprintf("AttributeTables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MasterSegmentDetailValidationError{
					field:  fmt.Sprintf("AttributeTables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBehaviorTables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MasterSegmentDetailValidationError{
						field:  fmt.Sprintf("BehaviorTables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MasterSegmentDetailValidationError{
						field:  fmt.Sprintf("BehaviorTables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MasterSegmentDetailValidationError{
					field:  fmt.Sprintf("BehaviorTables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAudienceSchema() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MasterSegmentDetailValidationError{
						field:  fmt.Sprintf("AudienceSchema[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MasterSegmentDetailValidationError{
						field:  fmt.Sprintf("AudienceSchema[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MasterSegmentDetailValidationError{
					field:  fmt.Sprintf("AudienceSchema[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MasterSegmentDetailMultiError(errors)
	}

	return nil
}

// MasterSegmentDetailMultiError is an error wrapping multiple validation
// errors returned by MasterSegmentDetail.ValidateAll() if the designated
// constraints aren't met.
type MasterSegmentDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MasterSegmentDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MasterSegmentDetailMultiError) AllErrors() []error { return m }

// MasterSegmentDetailValidationError is the validation error returned by
// MasterSegmentDetail.Validate if the designated constraints aren't met.
type MasterSegmentDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MasterSegmentDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MasterSegmentDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MasterSegmentDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MasterSegmentDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MasterSegmentDetailValidationError) ErrorName() string {
	return "MasterSegmentDetailValidationError"
}

// Error satisfies the builtin error interface
func (e MasterSegmentDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMasterSegmentDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MasterSegmentDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MasterSegmentDetailValidationError{}

// Validate checks the field values on Segment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Segment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Segment with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SegmentMultiError, or nil if none found.
func (m *Segment) ValidateAll() error {
	return m.validate(true)
}

func (m *Segment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for MasterSegmentId

	// no validation rules for MasterSegmentName

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for Status

	if len(errors) > 0 {
		return SegmentMultiError(errors)
	}

	return nil
}

// SegmentMultiError is an error wrapping multiple validation errors returned
// by Segment.ValidateAll() if the designated constraints aren't met.
type SegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentMultiError) AllErrors() []error { return m }

// SegmentValidationError is the validation error returned by Segment.Validate
// if the designated constraints aren't met.
type SegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentValidationError) ErrorName() string { return "SegmentValidationError" }

// Error satisfies the builtin error interface
func (e SegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentValidationError{}

// Validate checks the field values on MappingGophishProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MappingGophishProfile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MappingGophishProfile with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MappingGophishProfileMultiError, or nil if none found.
func (m *MappingGophishProfile) ValidateAll() error {
	return m.validate(true)
}

func (m *MappingGophishProfile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Email

	// no validation rules for FirstName

	// no validation rules for LastName

	// no validation rules for Position

	if len(errors) > 0 {
		return MappingGophishProfileMultiError(errors)
	}

	return nil
}

// MappingGophishProfileMultiError is an error wrapping multiple validation
// errors returned by MappingGophishProfile.ValidateAll() if the designated
// constraints aren't met.
type MappingGophishProfileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MappingGophishProfileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MappingGophishProfileMultiError) AllErrors() []error { return m }

// MappingGophishProfileValidationError is the validation error returned by
// MappingGophishProfile.Validate if the designated constraints aren't met.
type MappingGophishProfileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MappingGophishProfileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MappingGophishProfileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MappingGophishProfileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MappingGophishProfileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MappingGophishProfileValidationError) ErrorName() string {
	return "MappingGophishProfileValidationError"
}

// Error satisfies the builtin error interface
func (e MappingGophishProfileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMappingGophishProfile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MappingGophishProfileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MappingGophishProfileValidationError{}

// Validate checks the field values on DataDestination with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DataDestination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataDestination with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataDestinationMultiError, or nil if none found.
func (m *DataDestination) ValidateAll() error {
	return m.validate(true)
}

func (m *DataDestination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return DataDestinationMultiError(errors)
	}

	return nil
}

// DataDestinationMultiError is an error wrapping multiple validation errors
// returned by DataDestination.ValidateAll() if the designated constraints
// aren't met.
type DataDestinationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataDestinationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataDestinationMultiError) AllErrors() []error { return m }

// DataDestinationValidationError is the validation error returned by
// DataDestination.Validate if the designated constraints aren't met.
type DataDestinationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataDestinationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataDestinationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataDestinationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataDestinationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataDestinationValidationError) ErrorName() string { return "DataDestinationValidationError" }

// Error satisfies the builtin error interface
func (e DataDestinationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataDestination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataDestinationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataDestinationValidationError{}

// Validate checks the field values on DataSource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataSource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataSourceMultiError, or
// nil if none found.
func (m *DataSource) ValidateAll() error {
	return m.validate(true)
}

func (m *DataSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DataSourceMultiError(errors)
	}

	return nil
}

// DataSourceMultiError is an error wrapping multiple validation errors
// returned by DataSource.ValidateAll() if the designated constraints aren't met.
type DataSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataSourceMultiError) AllErrors() []error { return m }

// DataSourceValidationError is the validation error returned by
// DataSource.Validate if the designated constraints aren't met.
type DataSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataSourceValidationError) ErrorName() string { return "DataSourceValidationError" }

// Error satisfies the builtin error interface
func (e DataSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataSourceValidationError{}

// Validate checks the field values on DataSourceDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DataSourceDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataSourceDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataSourceDetailMultiError, or nil if none found.
func (m *DataSourceDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *DataSourceDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Type

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for ConnectionId

	if len(errors) > 0 {
		return DataSourceDetailMultiError(errors)
	}

	return nil
}

// DataSourceDetailMultiError is an error wrapping multiple validation errors
// returned by DataSourceDetail.ValidateAll() if the designated constraints
// aren't met.
type DataSourceDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataSourceDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataSourceDetailMultiError) AllErrors() []error { return m }

// DataSourceDetailValidationError is the validation error returned by
// DataSourceDetail.Validate if the designated constraints aren't met.
type DataSourceDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataSourceDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataSourceDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataSourceDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataSourceDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataSourceDetailValidationError) ErrorName() string { return "DataSourceDetailValidationError" }

// Error satisfies the builtin error interface
func (e DataSourceDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataSourceDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataSourceDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataSourceDetailValidationError{}

// Validate checks the field values on EnrichedDataSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnrichedDataSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedDataSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichedDataSourceMultiError, or nil if none found.
func (m *EnrichedDataSource) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedDataSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	if len(errors) > 0 {
		return EnrichedDataSourceMultiError(errors)
	}

	return nil
}

// EnrichedDataSourceMultiError is an error wrapping multiple validation errors
// returned by EnrichedDataSource.ValidateAll() if the designated constraints
// aren't met.
type EnrichedDataSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedDataSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedDataSourceMultiError) AllErrors() []error { return m }

// EnrichedDataSourceValidationError is the validation error returned by
// EnrichedDataSource.Validate if the designated constraints aren't met.
type EnrichedDataSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedDataSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedDataSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedDataSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedDataSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedDataSourceValidationError) ErrorName() string {
	return "EnrichedDataSourceValidationError"
}

// Error satisfies the builtin error interface
func (e EnrichedDataSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedDataSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedDataSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedDataSourceValidationError{}

// Validate checks the field values on EnrichedDataDestination with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnrichedDataDestination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedDataDestination with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichedDataDestinationMultiError, or nil if none found.
func (m *EnrichedDataDestination) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedDataDestination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	if len(errors) > 0 {
		return EnrichedDataDestinationMultiError(errors)
	}

	return nil
}

// EnrichedDataDestinationMultiError is an error wrapping multiple validation
// errors returned by EnrichedDataDestination.ValidateAll() if the designated
// constraints aren't met.
type EnrichedDataDestinationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedDataDestinationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedDataDestinationMultiError) AllErrors() []error { return m }

// EnrichedDataDestinationValidationError is the validation error returned by
// EnrichedDataDestination.Validate if the designated constraints aren't met.
type EnrichedDataDestinationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedDataDestinationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedDataDestinationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedDataDestinationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedDataDestinationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedDataDestinationValidationError) ErrorName() string {
	return "EnrichedDataDestinationValidationError"
}

// Error satisfies the builtin error interface
func (e EnrichedDataDestinationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedDataDestination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedDataDestinationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedDataDestinationValidationError{}

// Validate checks the field values on SegmentCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SegmentCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SegmentCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SegmentConditionMultiError, or nil if none found.
func (m *SegmentCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *SegmentCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAudienceCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SegmentConditionValidationError{
					field:  "AudienceCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SegmentConditionValidationError{
					field:  "AudienceCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAudienceCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SegmentConditionValidationError{
				field:  "AudienceCondition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AudienceSqlCondition

	for idx, item := range m.GetBehaviorConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SegmentConditionValidationError{
						field:  fmt.Sprintf("BehaviorConditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SegmentConditionValidationError{
						field:  fmt.Sprintf("BehaviorConditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SegmentConditionValidationError{
					field:  fmt.Sprintf("BehaviorConditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SegmentConditionMultiError(errors)
	}

	return nil
}

// SegmentConditionMultiError is an error wrapping multiple validation errors
// returned by SegmentCondition.ValidateAll() if the designated constraints
// aren't met.
type SegmentConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SegmentConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SegmentConditionMultiError) AllErrors() []error { return m }

// SegmentConditionValidationError is the validation error returned by
// SegmentCondition.Validate if the designated constraints aren't met.
type SegmentConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SegmentConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SegmentConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SegmentConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SegmentConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SegmentConditionValidationError) ErrorName() string { return "SegmentConditionValidationError" }

// Error satisfies the builtin error interface
func (e SegmentConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSegmentCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SegmentConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SegmentConditionValidationError{}

// Validate checks the field values on BehaviorCondition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BehaviorCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BehaviorCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BehaviorConditionMultiError, or nil if none found.
func (m *BehaviorCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *BehaviorCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BehaviorTableId

	if all {
		switch v := interface{}(m.GetWhereCondition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BehaviorConditionValidationError{
					field:  "WhereCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BehaviorConditionValidationError{
					field:  "WhereCondition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhereCondition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BehaviorConditionValidationError{
				field:  "WhereCondition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WhereSqlCondition

	for idx, item := range m.GetHavingConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BehaviorConditionValidationError{
						field:  fmt.Sprintf("HavingConditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BehaviorConditionValidationError{
						field:  fmt.Sprintf("HavingConditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BehaviorConditionValidationError{
					field:  fmt.Sprintf("HavingConditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BehaviorConditionMultiError(errors)
	}

	return nil
}

// BehaviorConditionMultiError is an error wrapping multiple validation errors
// returned by BehaviorCondition.ValidateAll() if the designated constraints
// aren't met.
type BehaviorConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BehaviorConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BehaviorConditionMultiError) AllErrors() []error { return m }

// BehaviorConditionValidationError is the validation error returned by
// BehaviorCondition.Validate if the designated constraints aren't met.
type BehaviorConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BehaviorConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BehaviorConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BehaviorConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BehaviorConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BehaviorConditionValidationError) ErrorName() string {
	return "BehaviorConditionValidationError"
}

// Error satisfies the builtin error interface
func (e BehaviorConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBehaviorCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BehaviorConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BehaviorConditionValidationError{}

// Validate checks the field values on Rule with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rule with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RuleMultiError, or nil if none found.
func (m *Rule) ValidateAll() error {
	return m.validate(true)
}

func (m *Rule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Field

	// no validation rules for Operator

	// no validation rules for Value

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuleValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuleValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Combinator

	if len(errors) > 0 {
		return RuleMultiError(errors)
	}

	return nil
}

// RuleMultiError is an error wrapping multiple validation errors returned by
// Rule.ValidateAll() if the designated constraints aren't met.
type RuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleMultiError) AllErrors() []error { return m }

// RuleValidationError is the validation error returned by Rule.Validate if the
// designated constraints aren't met.
type RuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleValidationError) ErrorName() string { return "RuleValidationError" }

// Error satisfies the builtin error interface
func (e RuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleValidationError{}

// Validate checks the field values on DataActionRun with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DataActionRun) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataActionRun with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DataActionRunMultiError, or
// nil if none found.
func (m *DataActionRun) ValidateAll() error {
	return m.validate(true)
}

func (m *DataActionRun) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ActionId

	// no validation rules for ActionType

	// no validation rules for Status

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataActionRunValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataActionRunValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataActionRunValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DataActionRunMultiError(errors)
	}

	return nil
}

// DataActionRunMultiError is an error wrapping multiple validation errors
// returned by DataActionRun.ValidateAll() if the designated constraints
// aren't met.
type DataActionRunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataActionRunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataActionRunMultiError) AllErrors() []error { return m }

// DataActionRunValidationError is the validation error returned by
// DataActionRun.Validate if the designated constraints aren't met.
type DataActionRunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataActionRunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataActionRunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataActionRunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataActionRunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataActionRunValidationError) ErrorName() string { return "DataActionRunValidationError" }

// Error satisfies the builtin error interface
func (e DataActionRunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataActionRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataActionRunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataActionRunValidationError{}

// Validate checks the field values on PredictModel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PredictModel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PredictModel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PredictModelMultiError, or
// nil if none found.
func (m *PredictModel) ValidateAll() error {
	return m.validate(true)
}

func (m *PredictModel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for MasterSegmentId

	// no validation rules for Status

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	if len(errors) > 0 {
		return PredictModelMultiError(errors)
	}

	return nil
}

// PredictModelMultiError is an error wrapping multiple validation errors
// returned by PredictModel.ValidateAll() if the designated constraints aren't met.
type PredictModelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PredictModelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PredictModelMultiError) AllErrors() []error { return m }

// PredictModelValidationError is the validation error returned by
// PredictModel.Validate if the designated constraints aren't met.
type PredictModelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PredictModelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PredictModelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PredictModelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PredictModelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PredictModelValidationError) ErrorName() string { return "PredictModelValidationError" }

// Error satisfies the builtin error interface
func (e PredictModelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPredictModel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PredictModelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PredictModelValidationError{}

// Validate checks the field values on EnrichedConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnrichedConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichedConnectionMultiError, or nil if none found.
func (m *EnrichedConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	if len(errors) > 0 {
		return EnrichedConnectionMultiError(errors)
	}

	return nil
}

// EnrichedConnectionMultiError is an error wrapping multiple validation errors
// returned by EnrichedConnection.ValidateAll() if the designated constraints
// aren't met.
type EnrichedConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedConnectionMultiError) AllErrors() []error { return m }

// EnrichedConnectionValidationError is the validation error returned by
// EnrichedConnection.Validate if the designated constraints aren't met.
type EnrichedConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedConnectionValidationError) ErrorName() string {
	return "EnrichedConnectionValidationError"
}

// Error satisfies the builtin error interface
func (e EnrichedConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedConnectionValidationError{}

// Validate checks the field values on EnrichedTable with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnrichedTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedTable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnrichedTableMultiError, or
// nil if none found.
func (m *EnrichedTable) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return EnrichedTableMultiError(errors)
	}

	return nil
}

// EnrichedTableMultiError is an error wrapping multiple validation errors
// returned by EnrichedTable.ValidateAll() if the designated constraints
// aren't met.
type EnrichedTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedTableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedTableMultiError) AllErrors() []error { return m }

// EnrichedTableValidationError is the validation error returned by
// EnrichedTable.Validate if the designated constraints aren't met.
type EnrichedTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedTableValidationError) ErrorName() string { return "EnrichedTableValidationError" }

// Error satisfies the builtin error interface
func (e EnrichedTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedTableValidationError{}

// Validate checks the field values on SourceTableMap with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceTableMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceTableMap with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceTableMapMultiError,
// or nil if none found.
func (m *SourceTableMap) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceTableMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetTable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceTableMapValidationError{
					field:  "Table",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceTableMapValidationError{
					field:  "Table",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceTableMapValidationError{
				field:  "Table",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceTableMapValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceTableMapValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceTableMapValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMappings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SourceTableMapValidationError{
						field:  fmt.Sprintf("Mappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SourceTableMapValidationError{
						field:  fmt.Sprintf("Mappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SourceTableMapValidationError{
					field:  fmt.Sprintf("Mappings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DataActionId

	if len(errors) > 0 {
		return SourceTableMapMultiError(errors)
	}

	return nil
}

// SourceTableMapMultiError is an error wrapping multiple validation errors
// returned by SourceTableMap.ValidateAll() if the designated constraints
// aren't met.
type SourceTableMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceTableMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceTableMapMultiError) AllErrors() []error { return m }

// SourceTableMapValidationError is the validation error returned by
// SourceTableMap.Validate if the designated constraints aren't met.
type SourceTableMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceTableMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceTableMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceTableMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceTableMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceTableMapValidationError) ErrorName() string { return "SourceTableMapValidationError" }

// Error satisfies the builtin error interface
func (e SourceTableMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceTableMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceTableMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceTableMapValidationError{}

// Validate checks the field values on DestinationMappings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DestinationMappings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DestinationMappings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DestinationMappingsMultiError, or nil if none found.
func (m *DestinationMappings) ValidateAll() error {
	return m.validate(true)
}

func (m *DestinationMappings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for ObjectType

	// no validation rules for ObjectName

	// no validation rules for ObjectId

	for idx, item := range m.GetMappings() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DestinationMappingsValidationError{
						field:  fmt.Sprintf("Mappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DestinationMappingsValidationError{
						field:  fmt.Sprintf("Mappings[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DestinationMappingsValidationError{
					field:  fmt.Sprintf("Mappings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DataActionId

	if len(errors) > 0 {
		return DestinationMappingsMultiError(errors)
	}

	return nil
}

// DestinationMappingsMultiError is an error wrapping multiple validation
// errors returned by DestinationMappings.ValidateAll() if the designated
// constraints aren't met.
type DestinationMappingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestinationMappingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestinationMappingsMultiError) AllErrors() []error { return m }

// DestinationMappingsValidationError is the validation error returned by
// DestinationMappings.Validate if the designated constraints aren't met.
type DestinationMappingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestinationMappingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestinationMappingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestinationMappingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestinationMappingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestinationMappingsValidationError) ErrorName() string {
	return "DestinationMappingsValidationError"
}

// Error satisfies the builtin error interface
func (e DestinationMappingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestinationMappings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestinationMappingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestinationMappingsValidationError{}

// Validate checks the field values on EnrichedMasterSegment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnrichedMasterSegment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedMasterSegment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichedMasterSegmentMultiError, or nil if none found.
func (m *EnrichedMasterSegment) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedMasterSegment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return EnrichedMasterSegmentMultiError(errors)
	}

	return nil
}

// EnrichedMasterSegmentMultiError is an error wrapping multiple validation
// errors returned by EnrichedMasterSegment.ValidateAll() if the designated
// constraints aren't met.
type EnrichedMasterSegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedMasterSegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedMasterSegmentMultiError) AllErrors() []error { return m }

// EnrichedMasterSegmentValidationError is the validation error returned by
// EnrichedMasterSegment.Validate if the designated constraints aren't met.
type EnrichedMasterSegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedMasterSegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedMasterSegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedMasterSegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedMasterSegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedMasterSegmentValidationError) ErrorName() string {
	return "EnrichedMasterSegmentValidationError"
}

// Error satisfies the builtin error interface
func (e EnrichedMasterSegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedMasterSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedMasterSegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedMasterSegmentValidationError{}

// Validate checks the field values on EnrichedSegment with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnrichedSegment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedSegment with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnrichedSegmentMultiError, or nil if none found.
func (m *EnrichedSegment) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedSegment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return EnrichedSegmentMultiError(errors)
	}

	return nil
}

// EnrichedSegmentMultiError is an error wrapping multiple validation errors
// returned by EnrichedSegment.ValidateAll() if the designated constraints
// aren't met.
type EnrichedSegmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedSegmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedSegmentMultiError) AllErrors() []error { return m }

// EnrichedSegmentValidationError is the validation error returned by
// EnrichedSegment.Validate if the designated constraints aren't met.
type EnrichedSegmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedSegmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedSegmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedSegmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedSegmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedSegmentValidationError) ErrorName() string { return "EnrichedSegmentValidationError" }

// Error satisfies the builtin error interface
func (e EnrichedSegmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedSegment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedSegmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedSegmentValidationError{}

// Validate checks the field values on MasterSegmentDetail_AttributeTable with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MasterSegmentDetail_AttributeTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MasterSegmentDetail_AttributeTable
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MasterSegmentDetail_AttributeTableMultiError, or nil if none found.
func (m *MasterSegmentDetail_AttributeTable) ValidateAll() error {
	return m.validate(true)
}

func (m *MasterSegmentDetail_AttributeTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RawTableId

	// no validation rules for RawTableName

	// no validation rules for ForeignKey

	// no validation rules for JoinKey

	for idx, item := range m.GetSelectedColumns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MasterSegmentDetail_AttributeTableValidationError{
						field:  fmt.Sprintf("SelectedColumns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MasterSegmentDetail_AttributeTableValidationError{
						field:  fmt.Sprintf("SelectedColumns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MasterSegmentDetail_AttributeTableValidationError{
					field:  fmt.Sprintf("SelectedColumns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MasterSegmentDetail_AttributeTableMultiError(errors)
	}

	return nil
}

// MasterSegmentDetail_AttributeTableMultiError is an error wrapping multiple
// validation errors returned by
// MasterSegmentDetail_AttributeTable.ValidateAll() if the designated
// constraints aren't met.
type MasterSegmentDetail_AttributeTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MasterSegmentDetail_AttributeTableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MasterSegmentDetail_AttributeTableMultiError) AllErrors() []error { return m }

// MasterSegmentDetail_AttributeTableValidationError is the validation error
// returned by MasterSegmentDetail_AttributeTable.Validate if the designated
// constraints aren't met.
type MasterSegmentDetail_AttributeTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MasterSegmentDetail_AttributeTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MasterSegmentDetail_AttributeTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MasterSegmentDetail_AttributeTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MasterSegmentDetail_AttributeTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MasterSegmentDetail_AttributeTableValidationError) ErrorName() string {
	return "MasterSegmentDetail_AttributeTableValidationError"
}

// Error satisfies the builtin error interface
func (e MasterSegmentDetail_AttributeTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMasterSegmentDetail_AttributeTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MasterSegmentDetail_AttributeTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MasterSegmentDetail_AttributeTableValidationError{}

// Validate checks the field values on MasterSegmentDetail_BehaviorTable with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MasterSegmentDetail_BehaviorTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MasterSegmentDetail_BehaviorTable
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MasterSegmentDetail_BehaviorTableMultiError, or nil if none found.
func (m *MasterSegmentDetail_BehaviorTable) ValidateAll() error {
	return m.validate(true)
}

func (m *MasterSegmentDetail_BehaviorTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for RawTableId

	// no validation rules for RawTableName

	// no validation rules for ForeignKey

	// no validation rules for JoinKey

	for idx, item := range m.GetSchema() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MasterSegmentDetail_BehaviorTableValidationError{
						field:  fmt.Sprintf("Schema[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MasterSegmentDetail_BehaviorTableValidationError{
						field:  fmt.Sprintf("Schema[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MasterSegmentDetail_BehaviorTableValidationError{
					field:  fmt.Sprintf("Schema[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MasterSegmentDetail_BehaviorTableMultiError(errors)
	}

	return nil
}

// MasterSegmentDetail_BehaviorTableMultiError is an error wrapping multiple
// validation errors returned by
// MasterSegmentDetail_BehaviorTable.ValidateAll() if the designated
// constraints aren't met.
type MasterSegmentDetail_BehaviorTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MasterSegmentDetail_BehaviorTableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MasterSegmentDetail_BehaviorTableMultiError) AllErrors() []error { return m }

// MasterSegmentDetail_BehaviorTableValidationError is the validation error
// returned by MasterSegmentDetail_BehaviorTable.Validate if the designated
// constraints aren't met.
type MasterSegmentDetail_BehaviorTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MasterSegmentDetail_BehaviorTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MasterSegmentDetail_BehaviorTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MasterSegmentDetail_BehaviorTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MasterSegmentDetail_BehaviorTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MasterSegmentDetail_BehaviorTableValidationError) ErrorName() string {
	return "MasterSegmentDetail_BehaviorTableValidationError"
}

// Error satisfies the builtin error interface
func (e MasterSegmentDetail_BehaviorTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMasterSegmentDetail_BehaviorTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MasterSegmentDetail_BehaviorTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MasterSegmentDetail_BehaviorTableValidationError{}

// Validate checks the field values on BehaviorCondition_HavingCondition with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BehaviorCondition_HavingCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BehaviorCondition_HavingCondition
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BehaviorCondition_HavingConditionMultiError, or nil if none found.
func (m *BehaviorCondition_HavingCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *BehaviorCondition_HavingCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Combinator

	if len(errors) > 0 {
		return BehaviorCondition_HavingConditionMultiError(errors)
	}

	return nil
}

// BehaviorCondition_HavingConditionMultiError is an error wrapping multiple
// validation errors returned by
// BehaviorCondition_HavingCondition.ValidateAll() if the designated
// constraints aren't met.
type BehaviorCondition_HavingConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BehaviorCondition_HavingConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BehaviorCondition_HavingConditionMultiError) AllErrors() []error { return m }

// BehaviorCondition_HavingConditionValidationError is the validation error
// returned by BehaviorCondition_HavingCondition.Validate if the designated
// constraints aren't met.
type BehaviorCondition_HavingConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BehaviorCondition_HavingConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BehaviorCondition_HavingConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BehaviorCondition_HavingConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BehaviorCondition_HavingConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BehaviorCondition_HavingConditionValidationError) ErrorName() string {
	return "BehaviorCondition_HavingConditionValidationError"
}

// Error satisfies the builtin error interface
func (e BehaviorCondition_HavingConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBehaviorCondition_HavingCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BehaviorCondition_HavingConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BehaviorCondition_HavingConditionValidationError{}

// Validate checks the field values on DataActionRun_MetaData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DataActionRun_MetaData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataActionRun_MetaData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DataActionRun_MetaDataMultiError, or nil if none found.
func (m *DataActionRun_MetaData) ValidateAll() error {
	return m.validate(true)
}

func (m *DataActionRun_MetaData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetObjectReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataActionRun_MetaDataValidationError{
					field:  "ObjectReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataActionRun_MetaDataValidationError{
					field:  "ObjectReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataActionRun_MetaDataValidationError{
				field:  "ObjectReference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MasterSegmentId

	if len(errors) > 0 {
		return DataActionRun_MetaDataMultiError(errors)
	}

	return nil
}

// DataActionRun_MetaDataMultiError is an error wrapping multiple validation
// errors returned by DataActionRun_MetaData.ValidateAll() if the designated
// constraints aren't met.
type DataActionRun_MetaDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataActionRun_MetaDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataActionRun_MetaDataMultiError) AllErrors() []error { return m }

// DataActionRun_MetaDataValidationError is the validation error returned by
// DataActionRun_MetaData.Validate if the designated constraints aren't met.
type DataActionRun_MetaDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataActionRun_MetaDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataActionRun_MetaDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataActionRun_MetaDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataActionRun_MetaDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataActionRun_MetaDataValidationError) ErrorName() string {
	return "DataActionRun_MetaDataValidationError"
}

// Error satisfies the builtin error interface
func (e DataActionRun_MetaDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataActionRun_MetaData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataActionRun_MetaDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataActionRun_MetaDataValidationError{}

// Validate checks the field values on DataActionRun_ObjectReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DataActionRun_ObjectReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DataActionRun_ObjectReference with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DataActionRun_ObjectReferenceMultiError, or nil if none found.
func (m *DataActionRun_ObjectReference) ValidateAll() error {
	return m.validate(true)
}

func (m *DataActionRun_ObjectReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return DataActionRun_ObjectReferenceMultiError(errors)
	}

	return nil
}

// DataActionRun_ObjectReferenceMultiError is an error wrapping multiple
// validation errors returned by DataActionRun_ObjectReference.ValidateAll()
// if the designated constraints aren't met.
type DataActionRun_ObjectReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataActionRun_ObjectReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataActionRun_ObjectReferenceMultiError) AllErrors() []error { return m }

// DataActionRun_ObjectReferenceValidationError is the validation error
// returned by DataActionRun_ObjectReference.Validate if the designated
// constraints aren't met.
type DataActionRun_ObjectReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataActionRun_ObjectReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataActionRun_ObjectReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataActionRun_ObjectReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataActionRun_ObjectReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataActionRun_ObjectReferenceValidationError) ErrorName() string {
	return "DataActionRun_ObjectReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e DataActionRun_ObjectReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDataActionRun_ObjectReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataActionRun_ObjectReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataActionRun_ObjectReferenceValidationError{}
